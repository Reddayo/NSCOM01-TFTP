import os
import re
import struct
import shutil
import socket as soc

# Constants
TFTP_SERVER_PORT = 69
DEFAULT_BLK_SIZE = 512
IPv4_PTRN = (
    r"^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]?|0)\.){3}"
    r"(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]?|0)$"
)
ERROR_CODES = {
    0: "Not defined, see error message",
    1: "File not found",
    2: "Access violation",
    3: "Disk full or allocation exceeded",
    4: "Illegal TFTP operation",
    5: "Unknown transfer ID",
    6: "File already exists",
    7: "No such user",
    8: "Denied option negotiation"
}


class TFTPClient:
    def __init__(self):
        self.destIP = "127.0.0.1"
        self.sock = soc.socket(soc.AF_INET, soc.SOCK_DGRAM)
        self.sock.settimeout(5)
        self.running = True

        # Commands that do not require extra arguments (others are handled separately)
        self.command_map = {
            "show-dest": self.show_dest,
            "close": self.close_connection,
            "?": self.show_help,
        }

        self.start()

    # --------------------------
    # Logging Helpers
    # --------------------------
    def log_info(self, message: str) -> None:
        print(f"[INF] {message}")

    def log_err(self, message: str) -> None:
        print(f"[ERR] {message}")

    def log_warn(self, message: str) -> None:
        print(f"[WARN] {message}")

    # --------------------------
    # Main Loop & Command Dispatch
    # --------------------------
    def start(self) -> None:
        self.log_info("Welcome to the TFTP Client!")
        self.log_info("Client Version 4.0")
        self.log_info("Author: Jusper Angelo M. Cesar")
        print("")
        self.log_info("Default destination IP set as 127.0.0.1. Use 'set-dest' to configure.")
        self.log_info("Enter ? for commands.")

        while self.running:
            user_input = input(">> ").strip()
            self.process_command(user_input)

    def process_command(self, input_line: str) -> None:
        tokens = input_line.split()
        if not tokens:
            self.log_err("No command entered.")
            return

        command = tokens[0].lower()
        args = tokens[1:]

        if command in ("put", "get"):
            parsed = self.parse_transfer_args(args)
            if parsed is None:
                return
            filename, output_filename, options = parsed
            if command == "put":
                self.handle_put(filename, output_filename, options)
            else:
                self.handle_get(filename, output_filename, options)
        elif command == "set-dest":
            if len(args) != 1:
                self.log_err("Invalid Syntax: set-dest [ip]")
                return
            self.set_dest(args[0])
        elif command in self.command_map:
            self.command_map[command]()
        else:
            self.log_err("Invalid command. Use '?' for help.")

    # --------------------------
    # Parsing Command Options
    # --------------------------
    def parse_transfer_args(self, args: list):
        filename = None
        output_filename = None
        options = {}
        i = 0
        while i < len(args):
            arg = args[i]
            if arg == "-b":
                if "blksize" in options:
                    self.log_err("Duplicate blksize flag detected.")
                    return None
                if i + 1 >= len(args) or not args[i + 1].isdigit():
                    self.log_err("Missing or invalid blksize value.")
                    return None
                blksize = int(args[i + 1])
                if blksize < 8 or blksize > 65464:
                    self.log_err(f"Block size is not in range [8:65464]: {blksize}")
                    return None
                options["blksize"] = blksize
                i += 1
            elif arg == "-t":
                if "tsize" in options:
                    self.log_err("Duplicate tsize flag detected.")
                    return None
                options["tsize"] = True
            elif arg == "-o":
                if output_filename is not None:
                    self.log_err("Duplicate output flag detected.")
                    return None
                if i + 1 >= len(args):
                    self.log_err("Missing or invalid output name.")
                    return None
                output_filename = args[i + 1]
                i += 1
            elif filename is None:
                filename = arg
            else:
                self.log_err(f"Unknown option: {arg}")
                return None
            i += 1

        if filename is None:
            self.log_err("Invalid Syntax: missing filename")
            return None

        if output_filename is None:
            output_filename = filename

        return filename, output_filename, options

    # --------------------------
    # Request & Option Building
    # --------------------------
    def build_options(self, options: dict) -> bytes:
        packet = b""
        for option, value in options.items():
            packet += option.encode() + b"\x00" + str(value).encode() + b"\x00"
        return packet

    def build_request_packet(self, opcode: int, filename: str, options: dict = None) -> bytes:
        if opcode not in (1, 2):
            raise ValueError("[ERR] Invalid opcode. Must be 1 (RRQ) or 2 (WRQ).")
        packet = opcode.to_bytes(2, "big") + filename.encode() + b"\x00" + b"octet" + b"\x00"
        if options:
            packet += self.build_options(options)
        self.log_info(f"Sending {packet} to ({self.destIP}, {TFTP_SERVER_PORT})...")
        return packet

    # --------------------------
    # ACK & Packet Helpers
    # --------------------------
    def send_ack(self, block: int, tid: tuple) -> None:
        ack_packet = struct.pack("!H", 4) + block.to_bytes(2, "big")
        self.sock.sendto(ack_packet, tid)
        self.log_info(f"Sent ACK for block {block} to {tid}.")

    def handle_error_packet(self, error_packet: bytes) -> None:
        opcode = int.from_bytes(error_packet[0:2], "big")
        if opcode != 5:
            self.log_err("Packet is not an error packet.")
            return
        code = int.from_bytes(error_packet[2:4], "big")
        msg = error_packet[4:].decode().strip("\x00")
        meaning = ERROR_CODES.get(code, "Unknown error code")
        self.log_err(f"Code {code}: {meaning}. Message: {msg}")
        self.log_info("Terminating process...")

    def send_error(self, code: int, message: str) -> None:
        err_packet = struct.pack("!HH", 5, code) + message.encode("ascii") + b"\x00"
        self.sock.sendto(err_packet, (self.destIP, TFTP_SERVER_PORT))
        self.log_info(f"[SEND ERR] Error packet sent. Code: {code}, Message: {message}")

    # --------------------------
    # Option Acknowledgment (OACK) Handler
    # --------------------------
    def handle_oack(self, data: bytes, options: dict):
        seen_options = set()
        acknowledged = False
        while data:
            try:
                name, data = data.split(b"\x00", 1)
                name = name.decode("ascii")
                if not data:
                    self.log_err("Malformed OACK packet (missing value)")
                    self.send_error(8, "Missing value.")
                    return None
                value, data = data.split(b"\x00", 1)
                try:
                    value_int = int(value.decode())
                except Exception:
                    self.log_err(f"Invalid value for option {name}: {value}")
                    self.send_error(8, "Invalid value for option.")
                    return None

                if name in seen_options:
                    self.log_err(f"Duplicate option detected: {name}")
                    self.send_error(8, "Duplicate option detected.")
                    return None

                if name not in options:
                    self.log_err(f"Option is not in sent options: {name}")
                    self.send_error(8, "Option is not in sent options.")
                    return None

                if name == "blksize":
                    if value_int <= options["blksize"]:
                        options[name] = value_int
                        acknowledged = True
                    else:
                        self.log_err(
                            f"Block size value exceeds the expected limit: {value_int} > {options['blksize']}"
                        )
                        self.send_error(8, "Block size value exceeds the expected limit.")
                        return None
                elif name == "tsize":
                    total, used, free = shutil.disk_usage("/")
                    if value_int > free:
                        self.log_err(
                            f"File size exceeds available disk space: {value_int} > {free}"
                        )
                        self.send_error(3, "File size exceeds available disk space.")
                        return None
                    else:
                        acknowledged = True

                seen_options.add(name)
            except Exception:
                self.log_err("Malformed OACK packet")
                return None

        # If blksize wasnâ€™t acknowledged, use default
        if "blksize" not in seen_options:
            options["blksize"] = DEFAULT_BLK_SIZE

        return acknowledged, options

    # --------------------------
    # File Reception (GET)
    # --------------------------
    def receive_file(
        self, start: int, filename: str, first_packet: bytes, tid: tuple, blksize: int
    ) -> None:
        last_block = start - 1
        try:
            with open(filename, "wb") as file:
                # Handle OACK when expected
                if start == 0:
                    opcode = int.from_bytes(first_packet[0:2], "big")
                    if opcode == 6:
                        ack_packet = struct.pack("!H", 4) + (0).to_bytes(2, "big")
                        self.sock.sendto(ack_packet, tid)
                        self.log_info(f"Received OACK (opcode 6), sent ACK for block 0 to {tid}.")
                        try:
                            first_packet, tid = self.sock.recvfrom(blksize + 4)
                        except Exception as e:
                            self.log_err(f"Failed to receive data: {e}")
                            return
                        start = 1
                        last_block = 0
                    else:
                        self.log_err(f"Expected OACK (opcode 6) but received opcode {opcode}, aborting...")
                        return

                # Main loop for DATA packets (opcode 3)
                while True:
                    opcode = int.from_bytes(first_packet[0:2], "big")
                    if opcode == 5:
                        self.handle_error_packet(first_packet)
                        return
                    elif opcode != 3:
                        self.log_err(f"Unexpected opcode {opcode} received, aborting...")
                        return

                    block_num = int.from_bytes(first_packet[2:4], "big")
                    if block_num == last_block:
                        self.log_warn(f"Duplicate block {block_num} received; ignoring duplicate.")
                    else:
                        file.write(first_packet[4:])
                        last_block = block_num
                        self.send_ack(block_num, tid)

                    # If data portion is smaller than negotiated block size, it is the final packet
                    if len(first_packet) < blksize + 4:
                        self.log_info(f"File '{filename}' received successfully.")
                        break

                    try:
                        first_packet, tid = self.sock.recvfrom(blksize + 4)
                        
                    except Exception as e:
                        self.log_err(f"Failed to receive data: {e}")
                        return
            self.log_info("File transfer complete.")
        except Exception as e:
            self.log_err(f"Error writing file: {e}")

    # --------------------------
    # PUT (Upload) Handler
    # --------------------------
    def handle_put(self, filename: str, output_filename: str, options: dict) -> None:
        if not os.path.exists(filename):
            self.log_err(f"File does not exist: {filename}")
            return
        self.log_info("File exists. Proceeding with transfer.")

        if options.get("tsize"):
            options["tsize"] = os.path.getsize(filename)

        # Send WRQ packet (opcode 2)
        request_packet = self.build_request_packet(2, output_filename, options)
        self.sock.sendto(request_packet, (self.destIP, TFTP_SERVER_PORT))

        try:
            r_packet, tid = self.sock.recvfrom(DEFAULT_BLK_SIZE + 4)
            self.log_info(f"Received {r_packet} from {tid}...")
        except Exception as e:
            self.log_err(f"Failed to receive data: {e}")
            return

        opcode = int.from_bytes(r_packet[0:2], "big")
        if opcode == 4:
            blksize = DEFAULT_BLK_SIZE
            if options:
                self.log_warn(f"The options {options} were discarded.")
        elif opcode == 5:
            self.handle_error_packet(r_packet)
            return
        elif opcode == 6:
            result = self.handle_oack(r_packet[2:], options)
            if result is None:
                return
            acknowledged, options = result
            blksize = options.get("blksize", DEFAULT_BLK_SIZE)
        else:
            self.log_err(f"Unexpected opcode {opcode} received in PUT, aborting...")
            return

        try:
            with open(filename, "rb") as file:
                filesize = os.path.getsize(filename)
                block_number = 1
                max_retries = 5

                while (chunk := file.read(blksize)):
                    data_packet = struct.pack("!H", 3) + block_number.to_bytes(2, "big") + chunk
                    self.sock.sendto(data_packet, tid)
                    retries = 0
                    while True:
                        try:
                            ack_response, _ = self.sock.recvfrom(blksize + 4)
                            self.log_info(f"Received {ack_response} from {tid}...")
                        except soc.timeout:
                            retries += 1
                            self.log_warn(f"Timeout, resending block {block_number}...")
                            self.sock.sendto(data_packet, tid)
                            if retries >= max_retries:
                                self.log_err("Max retries has been reached, terminating process...")
                                return
                            continue

                        ack_opcode = int.from_bytes(ack_response[0:2], "big")
                        ack_block = int.from_bytes(ack_response[2:4], "big")
                        if ack_opcode == 5:
                            self.handle_error_packet(ack_response)
                            return
                        if ack_opcode == 4:
                            if ack_block == block_number:
                                self.log_info(f"Received correct ACK for block {block_number}")
                                break
                            elif ack_block < block_number:
                                self.log_warn(f"Duplicate ACK {ack_block}, ignoring...")
                                continue
                            else:
                                self.log_err(f"Out-of-order ACK {ack_block}, aborting...")
                                return
                    block_number += 1

                # If file size is an exact multiple of the block size, send an empty data packet.
                if filesize % blksize == 0:
                    empty_packet = struct.pack("!H", 3) + block_number.to_bytes(2, "big")
                    self.sock.sendto(empty_packet, tid)
                    self.log_info(f"Empty packet sent for block {block_number}.")
                    retries = 0
                    while True:
                        try:
                            ack_response, _ = self.sock.recvfrom(blksize + 4)
                            self.log_info(f"Received {ack_response} from {tid}...")
                        except soc.timeout:
                            retries += 1
                            self.log_warn(f"Timeout, resending block {block_number}...")
                            self.sock.sendto(empty_packet, tid)
                            if retries >= max_retries:
                                self.log_err("Max retries has been reached, terminating process...")
                                return
                            continue

                        ack_opcode = int.from_bytes(ack_response[0:2], "big")
                        ack_block = int.from_bytes(ack_response[2:4], "big")
                        if ack_opcode == 5:
                            self.handle_error_packet(ack_response)
                            return
                        if ack_opcode == 4:
                            if ack_block == block_number:
                                self.log_info(f"Received correct ACK for block {block_number}")
                                break
                            else:
                                self.log_warn(f"Duplicate/old ACK {ack_block}, resending block {block_number}...")
                                self.sock.sendto(empty_packet, tid)
                                continue

            self.log_info(f"{filename} has been sent successfully.")
        except Exception as e:
            self.log_err(f"Error during file transfer: {e}")

    # --------------------------
    # GET (Download) Handler
    # --------------------------
    def handle_get(self, filename: str, output_filename: str, options: dict) -> None:
        if options.get("tsize"):
            options["tsize"] = 0

        # Send RRQ packet (opcode 1)
        request_packet = self.build_request_packet(1, filename, options)
        self.sock.sendto(request_packet, (self.destIP, TFTP_SERVER_PORT))

        try:
            r_packet, tid = self.sock.recvfrom(DEFAULT_BLK_SIZE + 4)
            self.log_info(f"Received {r_packet} from {tid}...")
            
        except Exception as e:
            self.log_err(f"Failed to receive data: {e}")
            return

        opcode = int.from_bytes(r_packet[0:2], "big")
        if opcode == 3:
            blksize = DEFAULT_BLK_SIZE
            start = 1
        elif opcode == 6:
            result = self.handle_oack(r_packet[2:], options)
            if result is None:
                return
            acknowledged, options = result
            blksize = options.get("blksize", DEFAULT_BLK_SIZE)
            start = 0 if acknowledged else 1
        elif opcode == 5:
            self.handle_error_packet(r_packet)
            return
        else:
            self.log_err(f"Received invalid packet in RRQ, {opcode} not in (3, 5, 6)")
            return

        self.receive_file(start, output_filename, r_packet, tid, blksize)

    # --------------------------
    # Utility Commands
    # --------------------------
    def set_dest(self, ip: str) -> None:
        if re.match(IPv4_PTRN, ip):
            self.destIP = ip
            self.log_info(f"Destination IP address set to {ip}")
        else:
            self.log_err(f"Invalid IP address {ip}")

    def show_dest(self) -> None:
        self.log_info(f"Destination IP address is set to {self.destIP}")

    def close_connection(self) -> None:
        self.log_info("Closing the program.")
        self.running = False

    def show_help(self) -> None:
        print("Commands:")
        print("  put [file] [options]           upload a file to the server")
        print("  get [file] [options]           download a file from the server")
        print("  set-dest [ip]                  set destination ip")
        print("  show-dest                      show destination ip")
        print("  close                          close the program")
        print("  ?                              show this help message")
        print("")
        print("Options:")
        print("  -b [value]                    add tftp block size option")
        print("  -t                            toggle tftp transfer size option")
        print("  -o [file]                     rename output file")


if __name__ == "__main__":
    client = TFTPClient()
